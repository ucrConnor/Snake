/*SparkFun code, firmware, and software is released under the MIT License(http://opensource.org/licenses/MIT).

The MIT License (MIT)

Copyright (c) 2016 SparkFun Electronics

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, 
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*/


#ifndef LCD_H
#define LCD_H

#include <avr/pgmspace.h>

void  SetBit(unsigned char x, unsigned char k, unsigned char b) {
	PORTC = (b ? PORTC | (0x01 << k) : PORTC & ~(0x01 << k));
}
/*
____________________________________________________________________________________________
Code in this comment block was adapted for ATMEGA 1284 from code given by SparkFun at https://github.com/sparkfun/GraphicLCD_Nokia_5110/blob/master/Firmware/Nokia-5100-LCD-Example/LCD_Functions.h
*/
#define PIN_SCE   PC3
#define PIN_RESET PC4
#define PIN_DC    PC5
#define PIN_SDIN  PC6
#define PIN_SCLK  PC7


#define LOW	 0
#define HIGH 1

#define LCD_COMMAND LOW
#define LCD_DATA    HIGH

#define LCD_WIDTH  84
#define LCD_HEIGHT 48


static const unsigned char ASCII[][5] PROGMEM = {
	// First 32 characters (0x00-0x19) are ignored. These are
	// non-displayable, control characters.
	{0x00, 0x00, 0x00, 0x00, 0x00} // 0x20
	,{0x00, 0x00, 0x5f, 0x00, 0x00} // 0x21 !
	,{0x00, 0x07, 0x00, 0x07, 0x00} // 0x22 "
	,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 0x23 #
	,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 0x24 $
	,{0x23, 0x13, 0x08, 0x64, 0x62} // 0x25 %
	,{0x36, 0x49, 0x55, 0x22, 0x50} // 0x26 &
	,{0x00, 0x05, 0x03, 0x00, 0x00} // 0x27 '
	,{0x00, 0x1c, 0x22, 0x41, 0x00} // 0x28 (
	,{0x00, 0x41, 0x22, 0x1c, 0x00} // 0x29 )
	,{0x14, 0x08, 0x3e, 0x08, 0x14} // 0x2a *
	,{0x08, 0x08, 0x3e, 0x08, 0x08} // 0x2b +
	,{0x00, 0x50, 0x30, 0x00, 0x00} // 0x2c ,
	,{0x08, 0x08, 0x08, 0x08, 0x08} // 0x2d -
	,{0x00, 0x60, 0x60, 0x00, 0x00} // 0x2e .
	,{0x20, 0x10, 0x08, 0x04, 0x02} // 0x2f /
	,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 0x30 0
	,{0x00, 0x42, 0x7f, 0x40, 0x00} // 0x31 1
	,{0x42, 0x61, 0x51, 0x49, 0x46} // 0x32 2
	,{0x21, 0x41, 0x45, 0x4b, 0x31} // 0x33 3
	,{0x18, 0x14, 0x12, 0x7f, 0x10} // 0x34 4
	,{0x27, 0x45, 0x45, 0x45, 0x39} // 0x35 5
	,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 0x36 6
	,{0x01, 0x71, 0x09, 0x05, 0x03} // 0x37 7
	,{0x36, 0x49, 0x49, 0x49, 0x36} // 0x38 8
	,{0x06, 0x49, 0x49, 0x29, 0x1e} // 0x39 9
	,{0x00, 0x36, 0x36, 0x00, 0x00} // 0x3a :
	,{0x00, 0x56, 0x36, 0x00, 0x00} // 0x3b ;
	,{0x08, 0x14, 0x22, 0x41, 0x00} // 0x3c <
	,{0x14, 0x14, 0x14, 0x14, 0x14} // 0x3d =
	,{0x00, 0x41, 0x22, 0x14, 0x08} // 0x3e >
	,{0x02, 0x01, 0x51, 0x09, 0x06} // 0x3f ?
	,{0x32, 0x49, 0x79, 0x41, 0x3e} // 0x40 @
	,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 0x41 A
	,{0x7f, 0x49, 0x49, 0x49, 0x36} // 0x42 B
	,{0x3e, 0x41, 0x41, 0x41, 0x22} // 0x43 C
	,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 0x44 D
	,{0x7f, 0x49, 0x49, 0x49, 0x41} // 0x45 E
	,{0x7f, 0x09, 0x09, 0x09, 0x01} // 0x46 F
	,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 0x47 G
	,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 0x48 H
	,{0x00, 0x41, 0x7f, 0x41, 0x00} // 0x49 I
	,{0x20, 0x40, 0x41, 0x3f, 0x01} // 0x4a J
	,{0x7f, 0x08, 0x14, 0x22, 0x41} // 0x4b K
	,{0x7f, 0x40, 0x40, 0x40, 0x40} // 0x4c L
	,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 0x4d M
	,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 0x4e N
	,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 0x4f O
	,{0x7f, 0x09, 0x09, 0x09, 0x06} // 0x50 P
	,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 0x51 Q
	,{0x7f, 0x09, 0x19, 0x29, 0x46} // 0x52 R
	,{0x46, 0x49, 0x49, 0x49, 0x31} // 0x53 S
	,{0x01, 0x01, 0x7f, 0x01, 0x01} // 0x54 T
	,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 0x55 U
	,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 0x56 V
	,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 0x57 W
	,{0x63, 0x14, 0x08, 0x14, 0x63} // 0x58 X
	,{0x07, 0x08, 0x70, 0x08, 0x07} // 0x59 Y
	,{0x61, 0x51, 0x49, 0x45, 0x43} // 0x5a Z
	,{0x00, 0x7f, 0x41, 0x41, 0x00} // 0x5b [
	,{0x02, 0x04, 0x08, 0x10, 0x20} // 0x5c \ (keep this to escape the backslash)
	,{0x00, 0x41, 0x41, 0x7f, 0x00} // 0x5d ]
	,{0x04, 0x02, 0x01, 0x02, 0x04} // 0x5e ^
	,{0x40, 0x40, 0x40, 0x40, 0x40} // 0x5f _
	,{0x00, 0x01, 0x02, 0x04, 0x00} // 0x60 `
	,{0x20, 0x54, 0x54, 0x54, 0x78} // 0x61 a
	,{0x7f, 0x48, 0x44, 0x44, 0x38} // 0x62 b
	,{0x38, 0x44, 0x44, 0x44, 0x20} // 0x63 c
	,{0x38, 0x44, 0x44, 0x48, 0x7f} // 0x64 d
	,{0x38, 0x54, 0x54, 0x54, 0x18} // 0x65 e
	,{0x08, 0x7e, 0x09, 0x01, 0x02} // 0x66 f
	,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 0x67 g
	,{0x7f, 0x08, 0x04, 0x04, 0x78} // 0x68 h
	,{0x00, 0x44, 0x7d, 0x40, 0x00} // 0x69 i
	,{0x20, 0x40, 0x44, 0x3d, 0x00} // 0x6a j
	,{0x7f, 0x10, 0x28, 0x44, 0x00} // 0x6b k
	,{0x00, 0x41, 0x7f, 0x40, 0x00} // 0x6c l
	,{0x7c, 0x04, 0x18, 0x04, 0x78} // 0x6d m
	,{0x7c, 0x08, 0x04, 0x04, 0x78} // 0x6e n
	,{0x38, 0x44, 0x44, 0x44, 0x38} // 0x6f o
	,{0x7c, 0x14, 0x14, 0x14, 0x08} // 0x70 p
	,{0x08, 0x14, 0x14, 0x18, 0x7c} // 0x71 q
	,{0x7c, 0x08, 0x04, 0x04, 0x08} // 0x72 r
	,{0x48, 0x54, 0x54, 0x54, 0x20} // 0x73 s
	,{0x04, 0x3f, 0x44, 0x40, 0x20} // 0x74 t
	,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 0x75 u
	,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 0x76 v
	,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 0x77 w
	,{0x44, 0x28, 0x10, 0x28, 0x44} // 0x78 x
	,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 0x79 y
	,{0x44, 0x64, 0x54, 0x4c, 0x44} // 0x7a z
	,{0x00, 0x08, 0x36, 0x41, 0x00} // 0x7b {
	,{0x00, 0x00, 0x7f, 0x00, 0x00} // 0x7c |
	,{0x00, 0x41, 0x36, 0x08, 0x00} // 0x7d }
	,{0x10, 0x08, 0x08, 0x10, 0x08} // 0x7e ~
	,{0x78, 0x46, 0x41, 0x46, 0x78} // 0x7f DEL
};

/* The displayMap variable stores a buffer representation of the
pixels on our display. There are 504 total bits in this array,
same as how many pixels there are on a 84 x 48 display.
Each unsigned char in this array covers a 8-pixel vertical block on the
display. Each successive unsigned char covers the next 8-pixel column over
until you reach the right-edge of the display and step down 8 rows.
To update the display, we first have to write to this array, then
call the updateDisplay() function, which sends this whole array
to the PCD8544.
Because the PCD8544 won't let us write individual pixels at a
time, this is how we can make targeted changes to the display. */
unsigned char displayMap[LCD_WIDTH * LCD_HEIGHT / 8] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,0)->(11,7) ~ These 12 unsigned chars cover an 8x12 block in the left corner of the display
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,0)->(23,7)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, // (24,0)->(35,7)
	0xF0, 0xF8, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0x1E, 0x0E, 0x02, 0x00, // (36,0)->(47,7)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,0)->(59,7)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,0)->(71,7)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,0)->(83,7)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,8)->(11,15)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,8)->(23,15)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // (24,8)->(35,15)
	0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, // (36,8)->(47,15)
	0xF8, 0xF0, 0xF8, 0xFE, 0xFE, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00, // (48,8)->(59,15)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,8)->(71,15)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,8)->(83,15)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,16)->(11,23)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,16)->(23,23)
	0x00, 0x00, 0xF8, 0xFC, 0xFE, 0xFE, 0xFF, 0xFF, 0xF3, 0xE0, 0xE0, 0xC0, // (24,16)->(35,23)
	0xC0, 0xC0, 0xE0, 0xE0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (36,16)->(47,23)
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0x00, 0x00, 0x00, // (48,16)->(59,23)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,16)->(71,23)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,16)->(83,23)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,24)->(11,31)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,24)->(23,31)
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (24,24)->(35,31)
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (36,24)->(47,31)
	0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, // (48,24)->(59,31)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,24)->(71,31)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,24)->(83,31)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,32)->(11,39)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,32)->(23,39)
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, // (24,32)->(35,39)
	0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, // (36,32)->(47,39)
	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,32)->(59,39)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,32)->(71,39)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,32)->(83,39)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,40)->(11,47)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,40)->(23,47)
	0x00, 0x00, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, // (24,40)->(35,47)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (36,40)->(47,47)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,40)->(59,47)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,40)->(71,47)
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,40)->(83,47) !!! The bottom right pixel!
};

// There are two memory banks in the LCD, data/RAM and commands.
// This function sets the DC pin high or low depending, and then
// sends the data unsigned char
void LCDWrite(unsigned char data_or_command, unsigned char data)
{

	//Send the data
	SetBit(PORTC, PIN_SCE, LOW);
	//Tell the LCD that we are writing either to data or a command
	SetBit(PORTC, PIN_DC, data_or_command);
	
	unsigned char i;
	//Shift out the data to be written highest bit first
	for (i = 0; i < 8; i++)  {
			
		if ((data >> (7-i)) & 0x01)
			SetBit(PORTC, PIN_SDIN, HIGH);
		else
			SetBit(PORTC, PIN_SDIN, LOW);

		SetBit(PORTC,PIN_SCLK, HIGH);
		SetBit(PORTC, PIN_SCLK, LOW);
		}
	
	SetBit(PORTC, PIN_SCE, HIGH);
}


// This function sets a pixel on displayMap to your preferred
// color. 1=HIGH, 0= LOW.
void setContrast(unsigned char contrast)
{
	LCDWrite(LCD_COMMAND, 0x21); //Tell LCD that extended commands follow
	LCDWrite(LCD_COMMAND, 0x80 | contrast); //Set LCD Vop (Contrast): Try 0xB1(good @ 3.3V) or 0xBF if your display is too dark
	LCDWrite(LCD_COMMAND, 0x20); //Set display mode
}
void setPixel(int x, int y, unsigned char bw)
{
	// First, double check that the coordinate is in range.
	if ((x >= 0) && (x < LCD_WIDTH) && (y >= 0) && (y < LCD_HEIGHT))
	{
		unsigned char shift = y % 8;

		if (bw) // If HIGH, set the bit.
		displayMap[x + (y/8)*LCD_WIDTH] |= 1<<shift;
		else   // If LOW clear the bit.
		displayMap[x + (y/8)*LCD_WIDTH] &= ~(1<<shift);
	}
}

void setChar(char character, int x, int y, unsigned char bw)
{
	unsigned char column; // temp unsigned char to store character's column bitmap
	for (int i=0; i<5; i++) // 5 columns (x) per character
	{
		column = pgm_read_byte(&ASCII[character - 0x20][i]);
		for (int j=0; j<8; j++) // 8 rows (y) per character
		{
			if (column & (0x01 << j)) // test bits to set pixels
			setPixel(x+i, y+j, bw);
			else
			setPixel(x+i, y+j, !bw);
		}
	}
}

// setStr draws a string of characters, calling setChar with
// progressive coordinates until it's done.
// This function was grabbed from the SparkFun ColorLCDShield
// library.
void setStr(char * dString, int x, int y, unsigned char bw)
{
	while (*dString != 0x00) // loop until null terminator
	{
		setChar(*dString++, x, y, bw);
		x+=5;
		for (int i=y; i<y+8; i++)
		{
			setPixel(x, i, !bw);
		}
		x++;
		if (x > (LCD_WIDTH - 5)) // Enables wrap around
		{
			x = 0;
			y += 8;
		}
	}
}

void clearDisplay()
{
	for (int i=0; i<(LCD_WIDTH * LCD_HEIGHT / 8); i++)
	{
		displayMap[i] = 0;
	}
}

// Helpful function to directly command the LCD to go to a
// specific x,y coordinate.
void gotoXY(int x, int y)
{
	LCDWrite(0, 0x80 | x);  // Column.
	LCDWrite(0, 0x40 | y);  // Row.  ?
}

// This will actually draw on the display, whatever is currently
// in the displayMap array.
void updateDisplay()
{
	gotoXY(0, 0);
	for (int i=0; i < (LCD_WIDTH * LCD_HEIGHT / 8); i++)
	{
		LCDWrite(LCD_DATA, displayMap[i]);
	}
}

void lcdBegin(void)
{
	//Reset the LCD to a known state
	SetBit(PORTC, PIN_RESET, HIGH);
	SetBit(PORTC, PIN_SCE, HIGH);
	//_delay_ms(10);
	SetBit(PORTC, PIN_RESET, LOW);
	//_delay_ms(70);
	SetBit(PORTC, PIN_RESET, HIGH);

	SetBit(PORTC, PIN_SCE, LOW);

	LCDWrite(LCD_COMMAND, 0x21); //Tell LCD extended commands follow
	LCDWrite(LCD_COMMAND, 0xC2); //Set LCD Vop (Contrast)
	LCDWrite(LCD_COMMAND, 0x06); //Set Temp coefficent
	LCDWrite(LCD_COMMAND, 0x14); //LCD bias mode 1:48 (try 0x13)
	//We must send 0x20 before modifying the display control mode
	LCDWrite(LCD_COMMAND, 0x20);
	LCDWrite(LCD_COMMAND, 0x09);
	setContrast(0xB9);
	LCDWrite(LCD_COMMAND, 0x0C); //Set display control, normal mode.
	clearDisplay();
}
/*
_____________________________________________________________________________________
*/
#endif

